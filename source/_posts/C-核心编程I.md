---
title: C++核心编程I
date: 2023-9-18 16:25:50
tags: 
     - c++
categories: 笔记
---

今天的内容包括内存分区模型、内联函数和拷贝构造函数。
<!-- more -->

# C++核心编程


### 1. 内存分区模型

- 代码区：存放函数的二进制代码，由操作系统进行管理
- 全局区：存放全局变量和静态变量以及常量
- 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等
- 堆区：由程序员分配和释放，若程序员不释放，程序结束由操作系统释放

### 2. 内联函数

在C++中，使用关键字 `inline` 可以将函数定义为内联函数。内联函数的特点是它们的定义必须在每个调用它们的源文件中可见，通常这意味着函数的定义通常会写在头文件（.h）中。

目的：在编译时将函数的代码嵌入到调用它们的地方，而不是像普通函数一样在链接时进行函数调用。因此，如果函数定义不在可见范围内，编译器无法将其内联到调用点。

**在头文件中声明内联函数的原型（函数声明），并在同一头文件中定义函数的具体实现。**

```c++
#构造函数可以直接赋初值，构造函数特性
complex (double r = 0, double i = 0) : re(r),im(i){}
```

***1. 不带指针的构造函数多半不需要写析构函数***	     	**如果class里面带指针，就必须有拷贝构造和拷贝复制**

**2. 写在class里面的方法是内联函数（建议编译器内联，最后还是看编译器）**

***3. 数据一定要放在private里面，构造函数可以放在private里面，详情见后***

以下的常成员函数在常量对象调用时起作用，若没加 `const`常量对象调用时会报错 ,所以该加`const`的地方一定要加

```c++

double real() const { return re; }  #常成员函数

```

- ***参数传递尽量用引用，返回也是***
- ***同一个class的不同object之间互为友元（firend)***
- ***临时对象  typename ()***

- **如果class里面带指针，就必须有拷贝构造和拷贝复制**

<img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230920163619993.png" alt="image-20230920163619993" style="zoom:50%;" />

​																									浅拷贝：只拷贝指针

b = a,如果使用编译器默认的函数，是浅拷贝，有可能导致内存泄漏

### 3. **拷贝构造函数**

![image-20230920163938278](https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230920163938278.png)

													深拷贝:复制内存

**拷贝赋值函数**：把左边拷贝的右边分三步：1. 先把右边清空，2. 重新分配右边跟左边一样大的内存，3. 拷贝

<img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230920164727873.png" alt="image-20230920164727873" style="zoom:50%;" />

![12](https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230920200351109.png)

变量可以声明多次，但只能定义一次

```c++
extern int a;		#声明
extern int a = 0;   #定义
```

**静态函数属于类，而不属于对象**

**模板类在编译时要把.h文件和.cpp文件都要添加**
